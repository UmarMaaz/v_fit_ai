
import { GoogleGenAI } from "@google/genai";
import { ImageData, FitStyle, GeminiPart } from "./types";

const MAX_RETRIES = 5;
const INITIAL_BACKOFF = 2000; // 2 seconds

const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

export async function generateFitting(
  personImage: ImageData,
  garmentImage: ImageData,
  fitStyle: FitStyle,
  onRetry: (seconds: number) => void
): Promise<string> {
  const ai = new GoogleGenAI({ apiKey: import.meta.env.VITE_GEMINI_API_KEY || '' });

  let retries = 0;

  const attempt = async (): Promise<string> => {
    try {
      const prompt = `
        TASK: Virtual Try-On / Fashion Compositing.
        
        INPUTS: 
        1. Person Image: Use this as the BASE. Keep the person's identity, face, body pose, limb positions, and background 100% UNCHANGED.
        2. Garment Image: Extract the color, fabric texture, patterns, and style from this item.
        
        INSTRUCTIONS:
        - Dramatically replace the person's existing clothing with the provided garment.
        - Drape the fabric realistically around the person's specific silhouette.
        - Adjust for ${fitStyle.toLowerCase()} fit preferences: ensure the fabric folds and overlaps naturally based on this style.
        - Maintain consistent lighting between the person and the new clothing.
        - DO NOT change the person's head, hands, feet, or environment.
        - The goal is a photorealistic "lookbook" style photograph.
      `;

      const parts: GeminiPart[] = [
        {
          inlineData: {
            mimeType: personImage.mimeType,
            data: personImage.base64
          }
        },
        {
          inlineData: {
            mimeType: garmentImage.mimeType,
            data: garmentImage.base64
          }
        },
        { text: prompt }
      ];

      const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash-image',
        contents: { parts },
        config: {
          imageConfig: {
            aspectRatio: "3:4"
          }
        }
      });

      if (!response.candidates?.[0]?.content?.parts) {
        throw new Error("No image generated by the model.");
      }

      for (const part of response.candidates[0].content.parts) {
        if (part.inlineData) {
          return `data:image/png;base64,${part.inlineData.data}`;
        }
      }

      throw new Error("Image data part not found in response.");

    } catch (error: any) {
      if (error.status === 429 && retries < MAX_RETRIES) {
        const backoff = INITIAL_BACKOFF * Math.pow(2, retries);
        const seconds = Math.ceil(backoff / 1000);
        onRetry(seconds);
        await sleep(backoff);
        retries++;
        return attempt();
      }

      if (error.status === 403) {
        throw new Error("Access denied. Please check your API key permissions.");
      }

      if (error.message?.includes("entity was not found")) {
        throw new Error("RE-AUTH_REQUIRED");
      }

      throw error;
    }
  };

  return attempt();
}
